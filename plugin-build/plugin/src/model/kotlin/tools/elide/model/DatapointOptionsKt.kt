//Generated by the protocol buffer compiler. DO NOT EDIT!
// source: elide/model/model.proto

package tools.elide.model;

@kotlin.jvm.JvmName("-initializedatapointOptions")
inline fun datapointOptions(block: tools.elide.model.DatapointOptionsKt.Dsl.() -> kotlin.Unit): tools.elide.model.DatapointOptions =
  tools.elide.model.DatapointOptionsKt.Dsl._create(tools.elide.model.DatapointOptions.newBuilder()).apply { block() }._build()
object DatapointOptionsKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  class Dsl private constructor(
    private val _builder: tools.elide.model.DatapointOptions.Builder
  ) {
    companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: tools.elide.model.DatapointOptions.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): tools.elide.model.DatapointOptions = _builder.build()

    /**
     * <pre>
     * Sets the visibility options for this data point. Depending on these options, a property or model may be exposed to
     * invoking code, protected from rewriting, and so on.
     * </pre>
     *
     * <code>.model.Visibility visibility = 1;</code>
     */
     var visibility: tools.elide.model.Visibility
      @JvmName("getVisibility")
      get() = _builder.getVisibility()
      @JvmName("setVisibility")
      set(value) {
        _builder.setVisibility(value)
      }
    /**
     * <pre>
     * Sets the visibility options for this data point. Depending on these options, a property or model may be exposed to
     * invoking code, protected from rewriting, and so on.
     * </pre>
     *
     * <code>.model.Visibility visibility = 1;</code>
     */
    fun clearVisibility() {
      _builder.clearVisibility()
    }

    /**
     * <pre>
     * Whether this data point (model or field or enum, etc) should be considered "required" for this model to be valid.
     * This setting is applied in various circumstances, usually when data crosses API boundaries.
     * </pre>
     *
     * <code>bool required = 2;</code>
     */
    var required: kotlin.Boolean
      @JvmName("getRequired")
      get() = _builder.getRequired()
      @JvmName("setRequired")
      set(value) {
        _builder.setRequired(value)
      }
    /**
     * <pre>
     * Whether this data point (model or field or enum, etc) should be considered "required" for this model to be valid.
     * This setting is applied in various circumstances, usually when data crosses API boundaries.
     * </pre>
     *
     * <code>bool required = 2;</code>
     */
    fun clearRequired() {
      _builder.clearRequired()
    }

    /**
     * <pre>
     * Whether this property contains a "concrete" sub-message, in which case, its properties are lifted to the parent
     * entity. During decoding, a property is added to indicate the concrete selection made. This is usually combined with
     * generic types in a one-of field, for instance, in `MenuProduct`.
     * </pre>
     *
     * <code>bool concrete = 3;</code>
     */
    var concrete: kotlin.Boolean
      @JvmName("getConcrete")
      get() = _builder.getConcrete()
      @JvmName("setConcrete")
      set(value) {
        _builder.setConcrete(value)
      }
    /**
     * <pre>
     * Whether this property contains a "concrete" sub-message, in which case, its properties are lifted to the parent
     * entity. During decoding, a property is added to indicate the concrete selection made. This is usually combined with
     * generic types in a one-of field, for instance, in `MenuProduct`.
     * </pre>
     *
     * <code>bool concrete = 3;</code>
     */
    fun clearConcrete() {
      _builder.clearConcrete()
    }

    /**
     * <pre>
     * Indicate to the data storage engine that a given field is ephemeral, and should not be stored, but rather held with
     * a calculated value for use in systems upstream from the data storage layer.
     * </pre>
     *
     * <code>bool ephemeral = 4;</code>
     */
    var ephemeral: kotlin.Boolean
      @JvmName("getEphemeral")
      get() = _builder.getEphemeral()
      @JvmName("setEphemeral")
      set(value) {
        _builder.setEphemeral(value)
      }
    /**
     * <pre>
     * Indicate to the data storage engine that a given field is ephemeral, and should not be stored, but rather held with
     * a calculated value for use in systems upstream from the data storage layer.
     * </pre>
     *
     * <code>bool ephemeral = 4;</code>
     */
    fun clearEphemeral() {
      _builder.clearEphemeral()
    }
  }
}
@kotlin.jvm.JvmSynthetic
inline fun tools.elide.model.DatapointOptions.copy(block: tools.elide.model.DatapointOptionsKt.Dsl.() -> kotlin.Unit): tools.elide.model.DatapointOptions =
  tools.elide.model.DatapointOptionsKt.Dsl._create(this.toBuilder()).apply { block() }._build()

